---
title: Framework Package
description: Complete framework package for API calls management, data fetching and state management in monorepo
---

# ğŸš€ Framework Package

The framework package is a complete and standard solution for managing API calls, data fetching, and state management in all monorepo projects.

## âœ¨ Key Features

- **ğŸ”§ Full TypeScript** - All types and interfaces
- **âš¡ React Query integration** - Smart caching and background updates
- **ğŸŒ Centralized HTTP Client** - Token management and error handling
- **ğŸ”„ Generic Hooks** - Reusable functionality
- **ğŸ“¦ Provider Pattern** - Easy setup
- **ğŸ—‚ï¸ Route Structure** - Organized API calls structure

## ğŸ—ï¸ Overall Structure

```
packages/framework/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ types/           # Core types and base response types
â”‚   â”œâ”€â”€ utils/           # HTTP client, endpoints, generic hooks
â”‚   â”œâ”€â”€ providers/       # Main framework provider
â”‚   â”œâ”€â”€ routes/          # API route implementations
â”‚   â”‚   â””â”€â”€ products/    # Complete route structure example
â”‚   â””â”€â”€ index.ts         # Main exports
â”œâ”€â”€ dist/                # Built files
â””â”€â”€ README.md
```

## ğŸ¯ Benefits of Using

 1. **Centralization**
All endpoints are defined in a central file (`api-endpoints.ts`) and no endpoint is hardcoded.

 2. **Type Safety**
All API calls are fully covered with TypeScript and no `any` type is used.

3. **Reusability**
Generic hooks are reusable for all types of API calls (GET, POST, PUT, DELETE).

4. **Error Management**
Central interceptors for error management, token handling, and notifications.

5. **Smart Caching**
React Query for smart caching, background updates, and optimistic updates.

6. **Organization**
Structured and predictable organization for all API routes.

## ğŸš€ Quick Start

### 1. Installation
```bash
pnpm add @workspace/framework
```

### 2. Setup Provider
```tsx
import { FrameworkProvider } from "@workspace/framework";

export default function RootLayout({ children }) {
  return (
    <FrameworkProvider>
      {children}
    </FrameworkProvider>
  );
}
```

### 3. Using Hooks
```tsx
import { useProductsQuery, useCreateProductMutation } from "@workspace/framework";

function ProductList() {
  const { data, isLoading, error } = useProductsQuery({
    pageNo: 1,
    rowCount: 10,
  });

  const createProduct = useCreateProductMutation();

  // Using data and mutations...
}
```

## ğŸ“š Different Sections

### [ğŸ”§ Setup & Installation](./framework/setup)
Complete guide for installing and setting up framework package

### [ğŸ“– Usage Guide](./framework/usage)
Guide for using hooks and API calls

### [ğŸ—ï¸ Route Structure](./framework/route-structure)
Structure and organization of API routes

### [â• Adding New Endpoints](./framework/adding-endpoints)
Guide for adding new endpoints

### [ğŸ¯ Examples](./framework/examples)
Practical and real-world examples

### [ğŸ“‹ API Reference](./framework/api-reference)
Complete API reference and types

## ğŸ¨ Complete Example

```tsx
"use client"

import { Button } from "@workspace/ui/components/button"
import { useProductsQuery, useCreateProductMutation } from "@workspace/framework"
import { useState } from "react"

export default function ProductManagement() {
  const [showProducts, setShowProducts] = useState(false)
  
  // Using framework hooks
  const { data: products, isLoading, error } = useProductsQuery({
    pageNo: 1,
    rowCount: 5,
    isActive: true,
  })

  const createProduct = useCreateProductMutation()

  const handleCreateProduct = async () => {
    try {
      await createProduct.mutateAsync({
        name: "Test Product",
        description: "A test product created via framework",
        price: 99.99,
        categoryId: "cat-1",
        isActive: true,
      })
      alert("Product created successfully!")
    } catch (error) {
      console.error("Failed to create product:", error)
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex gap-4">
        <Button 
          onClick={() => setShowProducts(!showProducts)}
          variant="outline"
        >
          {showProducts ? "Hide" : "Show"} Products
        </Button>
        
        <Button 
          onClick={handleCreateProduct}
          disabled={createProduct.isPending}
        >
          {createProduct.isPending ? "Creating..." : "Create Test Product"}
        </Button>
      </div>

      {showProducts && (
        <div>
          <h2 className="text-xl font-semibold mb-4">Products List</h2>
          
          {isLoading && <p>Loading products...</p>}
          {error && <p className="text-red-500">Error: {error.message}</p>}
          
          {products && (
            <div className="grid gap-4">
              {products.data?.entries.map((product) => (
                <div key={product.id} className="border rounded-lg p-4">
                  <h3 className="font-semibold">{product.name}</h3>
                  <p className="text-gray-600">{product.description}</p>
                  <p className="text-green-600 font-medium">${product.price}</p>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

## ğŸ”„ Usage Rules

### âœ… You Should Do:
1. **Always use `API_ENDPOINTS`**
2. **Raw functions in `get.ts`/`post.ts`**
3. **Hooks in `query.ts`**
4. **Types in `type.ts`**
5. **Use generic hooks**

### âŒ You Should Not Do:
1. **Hardcode endpoints** - `APIHttp.get("/users")` âŒ
2. **Direct APIHttp in UI** - Only use hooks
3. **Any type** - Always define interfaces
4. **Duplicate query keys**

## ğŸ¯ Conclusion

The framework package is a complete and standard solution for managing API calls in monorepo that makes code clean, maintainable, and scalable.

---

**Ready to get started? Check out the [Setup Guide](./setup)! ğŸš€**
