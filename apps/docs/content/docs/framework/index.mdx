---
title: Framework Package
description: Complete framework package for API calls management, data fetching and state management in monorepo
---

# 🚀 Framework Package

The framework package is a complete and standard solution for managing API calls, data fetching, and state management in all monorepo projects.

## ✨ Key Features

- **🔧 Full TypeScript** - All types and interfaces
- **⚡ React Query integration** - Smart caching and background updates
- **🌐 Centralized HTTP Client** - Token management and error handling
- **🔄 Generic Hooks** - Reusable functionality
- **📦 Provider Pattern** - Easy setup
- **🗂️ Route Structure** - Organized API calls structure

## 🏗️ Overall Structure

```
packages/framework/
├── src/
│   ├── types/           # Core types and base response types
│   ├── utils/           # HTTP client, endpoints, generic hooks
│   ├── providers/       # Main framework provider
│   ├── routes/          # API route implementations
│   │   └── products/    # Complete route structure example
│   └── index.ts         # Main exports
├── dist/                # Built files
└── README.md
```

## 🎯 Benefits of Using

 1. **Centralization**
All endpoints are defined in a central file (`api-endpoints.ts`) and no endpoint is hardcoded.

 2. **Type Safety**
All API calls are fully covered with TypeScript and no `any` type is used.

3. **Reusability**
Generic hooks are reusable for all types of API calls (GET, POST, PUT, DELETE).

4. **Error Management**
Central interceptors for error management, token handling, and notifications.

5. **Smart Caching**
React Query for smart caching, background updates, and optimistic updates.

6. **Organization**
Structured and predictable organization for all API routes.

## 🚀 Quick Start

### 1. Installation
```bash
pnpm add @workspace/framework
```

### 2. Setup Provider
```tsx
import { FrameworkProvider } from "@workspace/framework";

export default function RootLayout({ children }) {
  return (
    <FrameworkProvider>
      {children}
    </FrameworkProvider>
  );
}
```

### 3. Using Hooks
```tsx
import { useProductsQuery, useCreateProductMutation } from "@workspace/framework";

function ProductList() {
  const { data, isLoading, error } = useProductsQuery({
    pageNo: 1,
    rowCount: 10,
  });

  const createProduct = useCreateProductMutation();

  // Using data and mutations...
}
```

## 📚 Different Sections

### [🔧 Setup & Installation](./framework/setup)
Complete guide for installing and setting up framework package

### [📖 Usage Guide](./framework/usage)
Guide for using hooks and API calls

### [🏗️ Route Structure](./framework/route-structure)
Structure and organization of API routes

### [➕ Adding New Endpoints](./framework/adding-endpoints)
Guide for adding new endpoints

### [🎯 Examples](./framework/examples)
Practical and real-world examples

### [📋 API Reference](./framework/api-reference)
Complete API reference and types

## 🎨 Complete Example

```tsx
"use client"

import { Button } from "@workspace/ui/components/button"
import { useProductsQuery, useCreateProductMutation } from "@workspace/framework"
import { useState } from "react"

export default function ProductManagement() {
  const [showProducts, setShowProducts] = useState(false)
  
  // Using framework hooks
  const { data: products, isLoading, error } = useProductsQuery({
    pageNo: 1,
    rowCount: 5,
    isActive: true,
  })

  const createProduct = useCreateProductMutation()

  const handleCreateProduct = async () => {
    try {
      await createProduct.mutateAsync({
        name: "Test Product",
        description: "A test product created via framework",
        price: 99.99,
        categoryId: "cat-1",
        isActive: true,
      })
      alert("Product created successfully!")
    } catch (error) {
      console.error("Failed to create product:", error)
    }
  }

  return (
    <div className="space-y-6">
      <div className="flex gap-4">
        <Button 
          onClick={() => setShowProducts(!showProducts)}
          variant="outline"
        >
          {showProducts ? "Hide" : "Show"} Products
        </Button>
        
        <Button 
          onClick={handleCreateProduct}
          disabled={createProduct.isPending}
        >
          {createProduct.isPending ? "Creating..." : "Create Test Product"}
        </Button>
      </div>

      {showProducts && (
        <div>
          <h2 className="text-xl font-semibold mb-4">Products List</h2>
          
          {isLoading && <p>Loading products...</p>}
          {error && <p className="text-red-500">Error: {error.message}</p>}
          
          {products && (
            <div className="grid gap-4">
              {products.data?.entries.map((product) => (
                <div key={product.id} className="border rounded-lg p-4">
                  <h3 className="font-semibold">{product.name}</h3>
                  <p className="text-gray-600">{product.description}</p>
                  <p className="text-green-600 font-medium">${product.price}</p>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

## 🔄 Usage Rules

### ✅ You Should Do:
1. **Always use `API_ENDPOINTS`**
2. **Raw functions in `get.ts`/`post.ts`**
3. **Hooks in `query.ts`**
4. **Types in `type.ts`**
5. **Use generic hooks**

### ❌ You Should Not Do:
1. **Hardcode endpoints** - `APIHttp.get("/users")` ❌
2. **Direct APIHttp in UI** - Only use hooks
3. **Any type** - Always define interfaces
4. **Duplicate query keys**

## 🎯 Conclusion

The framework package is a complete and standard solution for managing API calls in monorepo that makes code clean, maintainable, and scalable.

---

**Ready to get started? Check out the [Setup Guide](./setup)! 🚀**
